// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# Zendesk Support API endpoints
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl) returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    resource isolated function get api/lotus/assignables/autocomplete\.json(ListAssigneeFieldAssignableGroupsAndAgentsSearchHeaders headers = {}, *ListAssigneeFieldAssignableGroupsAndAgentsSearchQueries queries) returns AssigneeFieldAssignableGroupsAndAgentsSearchResponse|error {
        string resourcePath = string `/api/lotus/assignables/autocomplete.json`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    resource isolated function get api/lotus/assignables/groups\.json(map<string|string[]> headers = {}) returns AssigneeFieldAssignableGroupsResponse|error {
        string resourcePath = string `/api/lotus/assignables/groups.json`;
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get api/lotus/assignables/groups/[int group_id]/agents\.json(ListAssigneeFieldAssignableGroupAgentsHeaders headers = {}) returns AssigneeFieldAssignableGroupAgentsResponse|error {
        string resourcePath = string `/api/lotus/assignables/groups/${getEncodedUri(group_id)}/agents.json`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Get sources by target
    #
    # + targetType - The type of object the relationship field is targeting.
    # The options are "zen:user", "zen:ticket", "zen:organization", and "zen:custom_object:CUSTOM_OBJECT_KEY"
    # + targetId - The id of the object the relationship field is targeting
    # + fieldId - The id of the lookup relationship field
    # + sourceType - The type of object the relationship field belongs to (example. ticket field belongs to a ticket object).
    # The options are "zen:user", "zen:ticket", "zen:organization", and "zen:custom_object:CUSTOM_OBJECT_KEY"
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/[string targetType]/[int targetId]/relationship_fields/[int fieldId]/[string sourceType](GetSourcesByTargetHeaders headers = {}) returns ReverseLookupResponse|error {
        string resourcePath = string `/api/v2/${getEncodedUri(targetType)}/${getEncodedUri(targetId)}/relationship_fields/${getEncodedUri(fieldId)}/${getEncodedUri(sourceType)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/account/settings(map<string|string[]> headers = {}) returns AccountSettingsResponse|error {
        string resourcePath = string `/api/v2/account/settings`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Update Account Settings
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/account/settings(map<string|string[]> headers = {}) returns AccountSettingsResponse|error {
        string resourcePath = string `/api/v2/account/settings`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Create Trial Account
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/accounts(map<string|string[]> headers = {}) returns TrialAccountResponse|error {
        string resourcePath = string `/api/v2/accounts`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Verify Subdomain Availability
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/accounts/available(VerifySubdomainAvailabilityHeaders headers = {}, *VerifySubdomainAvailabilityQueries queries) returns InlineResponse200|error {
        string resourcePath = string `/api/v2/accounts/available`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Activities
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/activities(ListActivitiesHeaders headers = {}, *ListActivitiesQueries queries) returns ActivitiesResponse|error {
        string resourcePath = string `/api/v2/activities`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Activity
    #
    # + activity_id - The activity ID
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/activities/[int activity_id](ShowActivityHeaders headers = {}) returns ActivityResponse|error {
        string resourcePath = string `/api/v2/activities/${getEncodedUri(activity_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Count Activities
    #
    # + headers - Headers to be sent with the request 
    # + return - Count of ticket activities 
    resource isolated function get api/v2/activities/count(map<string|string[]> headers = {}) returns ActivitiesCountResponse|error {
        string resourcePath = string `/api/v2/activities/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Report Channelback Error to Zendesk
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/any_channel/channelback/report_error(map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/any_channel/channelback/report_error`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Push Content to Support
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/any_channel/push(map<string|string[]> headers = {}) returns ChannelFrameworkPushResultsResponse|error {
        string resourcePath = string `/api/v2/any_channel/push`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Validate Token
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/any_channel/validate_token(map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/any_channel/validate_token`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Attachment
    #
    # + attachment_id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/attachments/[int attachment_id](ShowAttachmentHeaders headers = {}) returns AttachmentResponse|error {
        string resourcePath = string `/api/v2/attachments/${getEncodedUri(attachment_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Attachment for Malware
    #
    # + attachment_id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/attachments/[int attachment_id](AttachmentUpdateRequest payload, UpdateAttachmentHeaders headers = {}) returns AttachmentResponse|error {
        string resourcePath = string `/api/v2/attachments/${getEncodedUri(attachment_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Audit Logs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/audit_logs(ListAuditLogsHeaders headers = {}, *ListAuditLogsQueries queries) returns AuditLogsResponse|error {
        string resourcePath = string `/api/v2/audit_logs`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Audit Log
    #
    # + audit_log_id - The ID of the audit log
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/audit_logs/[int audit_log_id](ShowAuditLogHeaders headers = {}) returns AuditLogResponse|error {
        string resourcePath = string `/api/v2/audit_logs/${getEncodedUri(audit_log_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Export Audit Logs
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Accepted description 
    resource isolated function post api/v2/audit_logs/export(ExportAuditLogsHeaders headers = {}, *ExportAuditLogsQueries queries) returns string|error {
        string resourcePath = string `/api/v2/audit_logs/export`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Search Tags
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/autocomplete/tags(AutocompleteTagsHeaders headers = {}, *AutocompleteTagsQueries queries) returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/autocomplete/tags`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Automations
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/automations(map<string|string[]> headers = {}) returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Automation
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/automations(map<string|string[]> headers = {}) returns AutomationResponse|error {
        string resourcePath = string `/api/v2/automations`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Automation
    #
    # + automation_id - The ID of the automation
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/automations/[int automation_id](ShowAutomationHeaders headers = {}) returns AutomationResponse|error {
        string resourcePath = string `/api/v2/automations/${getEncodedUri(automation_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Automation
    #
    # + automation_id - The ID of the automation
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/automations/[int automation_id](UpdateAutomationHeaders headers = {}) returns AutomationResponse|error {
        string resourcePath = string `/api/v2/automations/${getEncodedUri(automation_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Automation
    #
    # + automation_id - The ID of the automation
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/automations/[int automation_id](DeleteAutomationHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/automations/${getEncodedUri(automation_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Active Automations
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/automations/active(map<string|string[]> headers = {}) returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations/active`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk Delete Automations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/automations/destroy_many(BulkDeleteAutomationsHeaders headers = {}, *BulkDeleteAutomationsQueries queries) returns error? {
        string resourcePath = string `/api/v2/automations/destroy_many`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Search Automations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/automations/search(SearchAutomationsHeaders headers = {}, *SearchAutomationsQueries queries) returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Many Automations
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/automations/update_many(map<string|string[]> headers = {}) returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations/update_many`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List Bookmarks
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/bookmarks(map<string|string[]> headers = {}) returns BookmarksResponse|error {
        string resourcePath = string `/api/v2/bookmarks`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Bookmark
    #
    # + headers - Headers to be sent with the request 
    # + return - Successfully created 
    resource isolated function post api/v2/bookmarks(BookmarkCreateRequest payload, map<string|string[]> headers = {}) returns BookmarkResponse|error {
        string resourcePath = string `/api/v2/bookmarks`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete Bookmark
    #
    # + bookmark_id - The ID of the bookmark
    # + headers - Headers to be sent with the request 
    # + return - No content 
    resource isolated function delete api/v2/bookmarks/[int bookmark_id](DeleteBookmarkHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/bookmarks/${getEncodedUri(bookmark_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Brands
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/brands(map<string|string[]> headers = {}) returns BrandsResponse|error {
        string resourcePath = string `/api/v2/brands`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Brand
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/brands(BrandCreateRequest payload, map<string|string[]> headers = {}) returns BrandResponse|error {
        string resourcePath = string `/api/v2/brands`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show a Brand
    #
    # + brand_id - The ID of the brand
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/brands/[int brand_id](ShowBrandHeaders headers = {}) returns BrandResponse|error {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update a Brand
    #
    # + brand_id - The ID of the brand
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function put api/v2/brands/[int brand_id](BrandUpdateRequest payload, UpdateBrandHeaders headers = {}) returns BrandResponse|error {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete a Brand
    #
    # + brand_id - The ID of the brand
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/brands/[int brand_id](DeleteBrandHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Check Host Mapping Validity for an Existing Brand
    #
    # + brand_id - The ID of the brand
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/brands/[int brand_id]/check_host_mapping(CheckHostMappingValidityForExistingBrandHeaders headers = {}) returns HostMappingObject|error {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}/check_host_mapping`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Check Host Mapping Validity
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/brands/check_host_mapping(CheckHostMappingValidityHeaders headers = {}, *CheckHostMappingValidityQueries queries) returns HostMappingObject|error {
        string resourcePath = string `/api/v2/brands/check_host_mapping`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Monitored Twitter Handles
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/channels/twitter/monitored_twitter_handles(map<string|string[]> headers = {}) returns TwitterChannelsResponse|error {
        string resourcePath = string `/api/v2/channels/twitter/monitored_twitter_handles`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Monitored Twitter Handle
    #
    # + monitored_twitter_handle_id - The ID of the custom agent role
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/channels/twitter/monitored_twitter_handles/[int monitored_twitter_handle_id](ShowMonitoredTwitterHandleHeaders headers = {}) returns TwitterChannelResponse|error {
        string resourcePath = string `/api/v2/channels/twitter/monitored_twitter_handles/${getEncodedUri(monitored_twitter_handle_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Ticket from Tweet
    #
    # + headers - Headers to be sent with the request 
    # + return - description 
    resource isolated function post api/v2/channels/twitter/tickets(map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/channels/twitter/tickets`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List Twicket statuses
    #
    # + comment_id - The ID of the comment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/channels/twitter/tickets/[int comment_id]/statuses(GettingTwicketStatusHeaders headers = {}, *GettingTwicketStatusQueries queries) returns TwitterChannelTwicketStatusResponse|error {
        string resourcePath = string `/api/v2/channels/twitter/tickets/${getEncodedUri(comment_id)}/statuses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Open Ticket in Agent's Browser
    #
    # + agent_id - ID of an agent
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/channels/voice/agents/[int agent_id]/tickets/[int ticket_id]/display(OpenTicketInAgentBrowserHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/channels/voice/agents/${getEncodedUri(agent_id)}/tickets/${getEncodedUri(ticket_id)}/display`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Open a User's Profile in an Agent's Browser
    #
    # + agent_id - ID of an agent
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/channels/voice/agents/[int agent_id]/users/[int user_id]/display(OpenUsersProfileInAgentBrowserHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/channels/voice/agents/${getEncodedUri(agent_id)}/users/${getEncodedUri(user_id)}/display`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Create Ticket or Voicemail Ticket
    #
    # + agent_id - ID of an agent
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/channels/voice/tickets(TicketCreateVoicemailTicketRequest payload, CreateTicketOrVoicemailTicketHeaders headers = {}) returns TicketResponse|error {
        string resourcePath = string `/api/v2/channels/voice/tickets`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Redact Chat Comment Attachment
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/chat_file_redactions/[int ticket_id](RedactChatCommentAttachmentHeaders headers = {}) returns TicketChatCommentRedactionResponse|error {
        string resourcePath = string `/api/v2/chat_file_redactions/${getEncodedUri(ticket_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Redact Chat Comment
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/chat_redactions/[int ticket_id](RedactChatCommentHeaders headers = {}) returns TicketChatCommentRedactionResponse|error {
        string resourcePath = string `/api/v2/chat_redactions/${getEncodedUri(ticket_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Redact Ticket Comment In Agent Workspace
    #
    # + ticket_comment_id - The ID of the ticket comment
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/comment_redactions/[int ticket_comment_id](RedactTicketCommentInAgentWorkspaceHeaders headers = {}) returns TicketCommentResponse|error {
        string resourcePath = string `/api/v2/comment_redactions/${getEncodedUri(ticket_comment_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Custom Objects
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects(map<string|string[]> headers = {}) returns CustomObjectsResponse|error {
        string resourcePath = string `/api/v2/custom_objects`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Custom Object
    #
    # + headers - Headers to be sent with the request 
    # + return - Created 
    resource isolated function post api/v2/custom_objects(CustomObjectsCreateRequest payload, map<string|string[]> headers = {}) returns CustomObjectResponse|error {
        string resourcePath = string `/api/v2/custom_objects`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Custom Object
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Custom Object 
    resource isolated function get api/v2/custom_objects/[string custom_object_key](ShowCustomObjectHeaders headers = {}) returns CustomObjectResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Custom Object
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/custom_objects/[string custom_object_key](DeleteCustomObjectHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Update Custom Object
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function patch api/v2/custom_objects/[string custom_object_key](UpdateCustomObjectHeaders headers = {}) returns CustomObjectResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # List Custom Object Fields
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/fields(ListCustomObjectFieldsHeaders headers = {}, *ListCustomObjectFieldsQueries queries) returns CustomObjectFieldsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Created 
    resource isolated function post api/v2/custom_objects/[string custom_object_key]/fields(CustomObjectFieldsCreateRequest payload, CreateCustomObjectFieldHeaders headers = {}) returns CustomObjectFieldResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Show Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_field_key_or_id - The key or id of a custom object field
    # + headers - Headers to be sent with the request 
    # + return - Custom Object Field 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/fields/[string custom_object_field_key_or_id](ShowCustomObjectFieldHeaders headers = {}) returns CustomObjectFieldResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/${getEncodedUri(custom_object_field_key_or_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_field_key_or_id - The key or id of a custom object field
    # + headers - Headers to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/custom_objects/[string custom_object_key]/fields/[string custom_object_field_key_or_id](DeleteCustomObjectFieldHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/${getEncodedUri(custom_object_field_key_or_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Update Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_field_key_or_id - The key or id of a custom object field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function patch api/v2/custom_objects/[string custom_object_key]/fields/[string custom_object_field_key_or_id](UpdateCustomObjectFieldHeaders headers = {}) returns CustomObjectFieldResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/${getEncodedUri(custom_object_field_key_or_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Reorder Custom Fields of an Object
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Reordered 
    resource isolated function put api/v2/custom_objects/[string custom_object_key]/fields/reorder(ReorderCustomObjectFieldsHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/reorder`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Custom Object Record Bulk Jobs
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Created 
    resource isolated function post api/v2/custom_objects/[string custom_object_key]/jobs(CustomObjectRecordsBulkCreateRequest payload, CustomObjectRecordBulkJobsHeaders headers = {}) returns CustomObjectRecordsJobsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/jobs`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Custom Object Fields Limit
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/limits/field_limit(CustomObjectFieldsLimitHeaders headers = {}) returns CustomObjectLimitsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/limits/field_limit`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Custom Object Records
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records(ListCustomObjectRecordsHeaders headers = {}, *ListCustomObjectRecordsQueries queries) returns CustomObjectRecordsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Created 
    resource isolated function post api/v2/custom_objects/[string custom_object_key]/records(CustomObjectRecordsCreateRequest payload, CreateCustomObjectRecordHeaders headers = {}) returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Custom Object Record by External Id
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/custom_objects/[string custom_object_key]/records(DeleteCustomObjectRecordByExternalIdHeaders headers = {}, *DeleteCustomObjectRecordByExternalIdQueries queries) returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Set Custom Object Record by External Id
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success 
    resource isolated function patch api/v2/custom_objects/[string custom_object_key]/records(CustomObjectRecordsUpsertRequest payload, UpsertCustomObjectRecordHeaders headers = {}, *UpsertCustomObjectRecordQueries queries) returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Show Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_record_id - The id of a custom object record
    # + headers - Headers to be sent with the request 
    # + return - Custom Object Record 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/[string custom_object_record_id](ShowCustomObjectRecordHeaders headers = {}) returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/${getEncodedUri(custom_object_record_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_record_id - The id of a custom object record
    # + headers - Headers to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/custom_objects/[string custom_object_key]/records/[string custom_object_record_id](DeleteCustomObjectRecordHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/${getEncodedUri(custom_object_record_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Update Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_record_id - The id of a custom object record
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function patch api/v2/custom_objects/[string custom_object_key]/records/[string custom_object_record_id](UpdateCustomObjectRecordHeaders headers = {}) returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/${getEncodedUri(custom_object_record_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Autocomplete Custom Object Record Search
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/autocomplete(AutocompleteCustomObjectRecordSearchHeaders headers = {}, *AutocompleteCustomObjectRecordSearchQueries queries) returns CustomObjectRecordsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/autocomplete`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Count Custom Object Records
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/count(CountCustomObjectRecordsHeaders headers = {}) returns InlineResponse2001|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/count`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Search Custom Object Records
    #
    # + custom_object_key - The key of a custom object
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/search(SearchCustomObjectRecordsHeaders headers = {}, *SearchCustomObjectRecordsQueries queries) returns CustomObjectRecordsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Custom Objects Limit
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/limits/object_limit(map<string|string[]> headers = {}) returns CustomObjectLimitsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/limits/object_limit`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Custom Object Records Limit
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_objects/limits/record_limit(map<string|string[]> headers = {}) returns CustomObjectLimitsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/limits/record_limit`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Custom Roles
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_roles(map<string|string[]> headers = {}) returns CustomRolesResponse|error {
        string resourcePath = string `/api/v2/custom_roles`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Custom Role
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/custom_roles(map<string|string[]> headers = {}) returns CustomRoleResponse|error {
        string resourcePath = string `/api/v2/custom_roles`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Custom Role
    #
    # + custom_role_id - The ID of the custom agent role
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/custom_roles/[int custom_role_id](ShowCustomRoleByIdHeaders headers = {}) returns CustomRoleResponse|error {
        string resourcePath = string `/api/v2/custom_roles/${getEncodedUri(custom_role_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Custom Role
    #
    # + custom_role_id - The ID of the custom agent role
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/custom_roles/[int custom_role_id](UpdateCustomRoleByIdHeaders headers = {}) returns CustomRoleResponse|error {
        string resourcePath = string `/api/v2/custom_roles/${getEncodedUri(custom_role_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Custom Role
    #
    # + custom_role_id - The ID of the custom agent role
    # + headers - Headers to be sent with the request 
    # + return - No Contetnt response 
    resource isolated function delete api/v2/custom_roles/[int custom_role_id](DeleteCustomRoleByIdHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/custom_roles/${getEncodedUri(custom_role_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Bulk Update Default Custom Ticket Status
    #
    # + headers - Headers to be sent with the request 
    # + return - Updated 
    resource isolated function put api/v2/custom_status/default(BulkUpdateDefaultCustomStatusRequest payload, map<string|string[]> headers = {}) returns BulkUpdateDefaultCustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_status/default`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List Custom Ticket Statuses
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List custom ticket statuses 
    resource isolated function get api/v2/custom_statuses(ListCustomStatusesHeaders headers = {}, *ListCustomStatusesQueries queries) returns CustomStatusesResponse|error {
        string resourcePath = string `/api/v2/custom_statuses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Custom Ticket Status
    #
    # + headers - Headers to be sent with the request 
    # + return - Created 
    resource isolated function post api/v2/custom_statuses(CustomStatusCreateRequest payload, map<string|string[]> headers = {}) returns CustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_statuses`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Custom Ticket Status
    #
    # + custom_status_id - The id of the custom status
    # + headers - Headers to be sent with the request 
    # + return - Custom Status 
    resource isolated function get api/v2/custom_statuses/[int custom_status_id](ShowCustomStatusHeaders headers = {}) returns CustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_statuses/${getEncodedUri(custom_status_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Custom Ticket Status
    #
    # + custom_status_id - The id of the custom status
    # + headers - Headers to be sent with the request 
    # + return - Updated 
    resource isolated function put api/v2/custom_statuses/[int custom_status_id](CustomStatusUpdateRequest payload, UpdateCustomStatusHeaders headers = {}) returns CustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_statuses/${getEncodedUri(custom_status_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Deleted Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/deleted_tickets(ListDeletedTicketsHeaders headers = {}, *ListDeletedTicketsQueries queries) returns ListDeletedTicketsResponse|error {
        string resourcePath = string `/api/v2/deleted_tickets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Ticket Permanently
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function delete api/v2/deleted_tickets/[int ticket_id](DeleteTicketPermanentlyHeaders headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/deleted_tickets/${getEncodedUri(ticket_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Restore a Previously Deleted Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Empty response 
    resource isolated function put api/v2/deleted_tickets/[int ticket_id]/restore(RestoreDeletedTicketHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/deleted_tickets/${getEncodedUri(ticket_id)}/restore`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Multiple Tickets Permanently
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete api/v2/deleted_tickets/destroy_many(BulkPermanentlyDeleteTicketsHeaders headers = {}, *BulkPermanentlyDeleteTicketsQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/deleted_tickets/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Restore Previously Deleted Tickets in Bulk
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Empty response 
    resource isolated function put api/v2/deleted_tickets/restore_many(BulkRestoreDeletedTicketsHeaders headers = {}, *BulkRestoreDeletedTicketsQueries queries) returns string|error {
        string resourcePath = string `/api/v2/deleted_tickets/restore_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Deleted Users
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/deleted_users(map<string|string[]> headers = {}) returns DeletedUsersResponse|error {
        string resourcePath = string `/api/v2/deleted_users`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Deleted User
    #
    # + deleted_user_id - The ID of the deleted user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/deleted_users/[int deleted_user_id](ShowDeletedUserHeaders headers = {}) returns DeletedUserResponse|error {
        string resourcePath = string `/api/v2/deleted_users/${getEncodedUri(deleted_user_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Permanently Delete User
    #
    # + deleted_user_id - The ID of the deleted user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/deleted_users/[int deleted_user_id](PermanentlyDeleteUserHeaders headers = {}) returns DeletedUserResponse|error {
        string resourcePath = string `/api/v2/deleted_users/${getEncodedUri(deleted_user_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Count Deleted Users
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/deleted_users/count(map<string|string[]> headers = {}) returns CountResponse|error {
        string resourcePath = string `/api/v2/deleted_users/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Items
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/dynamic_content/items(map<string|string[]> headers = {}) returns DynamicContentsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Item
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/dynamic_content/items(map<string|string[]> headers = {}) returns DynamicContentResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Item
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/dynamic_content/items/[int dynamic_content_item_id](ShowDynamicContentItemHeaders headers = {}) returns DynamicContentResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Item
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/dynamic_content/items/[int dynamic_content_item_id](UpdateDynamicContentItemHeaders headers = {}) returns DynamicContentResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Item
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/dynamic_content/items/[int dynamic_content_item_id](DeleteDynamicContentItemHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Variants
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants(DynamicContentListVariantsHeaders headers = {}) returns DynamicContentVariantsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants(CreateDynamicContentVariantHeaders headers = {}) returns DynamicContentVariantResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Show Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + dynammic_content_variant_id - The ID of the variant
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/[int dynammic_content_variant_id](ShowDynamicContentVariantHeaders headers = {}) returns DynamicContentVariantResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/${getEncodedUri(dynammic_content_variant_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + dynammic_content_variant_id - The ID of the variant
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/[int dynammic_content_variant_id](UpdateDynamicContentVariantHeaders headers = {}) returns DynamicContentVariantResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/${getEncodedUri(dynammic_content_variant_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + dynammic_content_variant_id - The ID of the variant
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/[int dynammic_content_variant_id](DeleteDynamicContentVariantHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/${getEncodedUri(dynammic_content_variant_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Create Many Variants
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/create_many(CreateManyDynamicContentVariantsHeaders headers = {}) returns DynamicContentVariantsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/create_many`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Update Many Variants
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/update_many(UpdateManyDynamicContentVariantsHeaders headers = {}) returns DynamicContentVariantsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/update_many`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Show Many Items
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/dynamic_content/items/show_many(ShowManyDynamicContentsHeaders headers = {}, *ShowManyDynamicContentsQueries queries) returns DynamicContentsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/show_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Memberships
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/group_memberships(map<string|string[]> headers = {}) returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/group_memberships`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Membership
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/group_memberships(map<string|string[]> headers = {}) returns GroupMembershipResponse|error {
        string resourcePath = string `/api/v2/group_memberships`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Membership
    #
    # + group_membership_id - The ID of the group membership
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/group_memberships/[int group_membership_id](ShowGroupMembershipByIdHeaders headers = {}) returns GroupMembershipResponse|error {
        string resourcePath = string `/api/v2/group_memberships/${getEncodedUri(group_membership_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Membership
    #
    # + group_membership_id - The ID of the group membership
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/group_memberships/[int group_membership_id](DeleteGroupMembershipHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/group_memberships/${getEncodedUri(group_membership_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Assignable Memberships
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/group_memberships/assignable(map<string|string[]> headers = {}) returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/group_memberships/assignable`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk Create Memberships
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/group_memberships/create_many(map<string|string[]> headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/group_memberships/create_many`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk Delete Memberships
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/group_memberships/destroy_many(GroupMembershipBulkDeleteHeaders headers = {}, *GroupMembershipBulkDeleteQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/group_memberships/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Group SLA Policies
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/group_slas/policies(map<string|string[]> headers = {}) returns GroupSLAPoliciesResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Group SLA Policy
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/group_slas/policies(map<string|string[]> headers = {}) returns GroupSLAPolicyResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Group SLA Policy
    #
    # + group_sla_policy_id - The id of the Group SLA policy
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/group_slas/policies/[int group_sla_policy_id](ShowGroupSLAPolicyHeaders headers = {}) returns GroupSLAPolicyResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies/${getEncodedUri(group_sla_policy_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Group SLA Policy
    #
    # + group_sla_policy_id - The id of the Group SLA policy
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/group_slas/policies/[int group_sla_policy_id](UpdateGroupSLAPolicyHeaders headers = {}) returns GroupSLAPolicyResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies/${getEncodedUri(group_sla_policy_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Group SLA Policy
    #
    # + group_sla_policy_id - The id of the Group SLA policy
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/group_slas/policies/[int group_sla_policy_id](DeleteGroupSLAPolicyHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/group_slas/policies/${getEncodedUri(group_sla_policy_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Retrieve Supported Filter Definition Items
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/group_slas/policies/definitions(map<string|string[]> headers = {}) returns GroupSLAPolicyFilterDefinitionResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies/definitions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Reorder Group SLA Policies
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/group_slas/policies/reorder(ReorderGroupSLAPoliciesHeaders headers = {}, *ReorderGroupSLAPoliciesQueries queries) returns string|error {
        string resourcePath = string `/api/v2/group_slas/policies/reorder`;
        map<Encoding> queryParamEncoding = {"group_sla_policy_ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Groups
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/groups(ListGroupsHeaders headers = {}, *ListGroupsQueries queries) returns GroupsResponse|error {
        string resourcePath = string `/api/v2/groups`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Group
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/groups(map<string|string[]> headers = {}) returns GroupResponse|error {
        string resourcePath = string `/api/v2/groups`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Group
    #
    # + group_id - The ID of the group
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/groups/[int group_id](ShowGroupByIdHeaders headers = {}) returns GroupResponse|error {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Group
    #
    # + group_id - The ID of the group
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/groups/[int group_id](UpdateGroupHeaders headers = {}) returns GroupResponse|error {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Group
    #
    # + group_id - The ID of the group
    # + headers - Headers to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/groups/[int group_id](DeleteGroupHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Memberships
    #
    # + group_id - The ID of the group
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/groups/[int group_id]/memberships(ListGroupMembershipsByGroupIdHeaders headers = {}) returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}/memberships`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Assignable Groups
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/groups/assignable(map<string|string[]> headers = {}) returns GroupsResponse|error {
        string resourcePath = string `/api/v2/groups/assignable`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Count Groups
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/groups/count(CountGroupsHeaders headers = {}) returns GroupsCountObject|error {
        string resourcePath = string `/api/v2/groups/count`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Ticket Import
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successfully created 
    resource isolated function post api/v2/imports/tickets(TicketImportRequest payload, TicketImportHeaders headers = {}, *TicketImportQueries queries) returns TicketResponse|error {
        string resourcePath = string `/api/v2/imports/tickets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Ticket Bulk Import
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/imports/tickets/create_many(TicketBulkImportRequest payload, TicketBulkImportHeaders headers = {}, *TicketBulkImportQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/imports/tickets/create_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Incremental Sample Export
    #
    # + incremental_resource - The resource requested for incremental sample export
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/[string incremental_resource]/sample(IncrementalSampleExportHeaders headers = {}, *IncrementalSampleExportQueries queries) returns TimeBasedExportIncrementalTicketsResponse|error {
        string resourcePath = string `/api/v2/incremental/${getEncodedUri(incremental_resource)}/sample`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Incremental Organization Export
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/organizations(IncrementalOrganizationExportHeaders headers = {}, *IncrementalOrganizationExportQueries queries) returns ExportIncrementalOrganizationsResponse|error {
        string resourcePath = string `/api/v2/incremental/organizations`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Incremental Attributes Values Export
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/routing/attribute_values(map<string|string[]> headers = {}) returns IncrementalSkillBasedRouting|error {
        string resourcePath = string `/api/v2/incremental/routing/attribute_values`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Incremental Attributes Export
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/routing/attributes(map<string|string[]> headers = {}) returns IncrementalSkillBasedRouting|error {
        string resourcePath = string `/api/v2/incremental/routing/attributes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Incremental Instance Values Export
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/routing/instance_values(map<string|string[]> headers = {}) returns IncrementalSkillBasedRouting|error {
        string resourcePath = string `/api/v2/incremental/routing/instance_values`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Incremental Ticket Event Export
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/ticket_events(IncrementalTicketEventsHeaders headers = {}, *IncrementalTicketEventsQueries queries) returns ExportIncrementalTicketEventsResponse|error {
        string resourcePath = string `/api/v2/incremental/ticket_events`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Ticket Metric Events
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/incremental/ticket_metric_events(ListTicketMetricEventsHeaders headers = {}, *ListTicketMetricEventsQueries queries) returns TicketMetricEventsResponse|error {
        string resourcePath = string `/api/v2/incremental/ticket_metric_events`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Incremental Ticket Export, Time Based
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/tickets(IncrementalTicketExportTimeHeaders headers = {}, *IncrementalTicketExportTimeQueries queries) returns TimeBasedExportIncrementalTicketsResponse|error {
        string resourcePath = string `/api/v2/incremental/tickets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Incremental Ticket Export, Cursor Based
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/tickets/cursor(IncrementalTicketExportCursorHeaders headers = {}, *IncrementalTicketExportCursorQueries queries) returns CursorBasedExportIncrementalTicketsResponse|error {
        string resourcePath = string `/api/v2/incremental/tickets/cursor`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Incremental User Export, Time Based
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/users(IncrementalUserExportTimeHeaders headers = {}, *IncrementalUserExportTimeQueries queries) returns TimeBasedExportIncrementalUsersResponse|error {
        string resourcePath = string `/api/v2/incremental/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Incremental User Export, Cursor Based
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/incremental/users/cursor(IncrementalUserExportCursorHeaders headers = {}, *IncrementalUserExportCursorQueries queries) returns CursorBasedExportIncrementalUsersResponse|error {
        string resourcePath = string `/api/v2/incremental/users/cursor`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Job Statuses
    #
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/job_statuses(map<string|string[]> headers = {}) returns JobStatusesResponse|error {
        string resourcePath = string `/api/v2/job_statuses`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Job Status
    #
    # + job_status_id - the Id of the Job status
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/job_statuses/[string job_status_id](ShowJobStatusHeaders headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/job_statuses/${getEncodedUri(job_status_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Many Job Statuses
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/job_statuses/show_many(ShowManyJobStatusesHeaders headers = {}, *ShowManyJobStatusesQueries queries) returns JobStatusesResponse|error {
        string resourcePath = string `/api/v2/job_statuses/show_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Locales
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/locales(map<string|string[]> headers = {}) returns LocalesResponse|error {
        string resourcePath = string `/api/v2/locales`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Locale
    #
    # + locale_id - The ID or the [BCP-47 code](https://en.wikipedia.org/wiki/IETF_language_tag) of the locale. Examples: es-419, en-us, pr-br
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/locales/[string locale_id](ShowLocaleByIdHeaders headers = {}) returns LocaleResponse|error {
        string resourcePath = string `/api/v2/locales/${getEncodedUri(locale_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Locales for Agent
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/locales/agent(map<string|string[]> headers = {}) returns LocalesResponse|error {
        string resourcePath = string `/api/v2/locales/agent`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Current Locale
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/locales/current(map<string|string[]> headers = {}) returns LocaleResponse|error {
        string resourcePath = string `/api/v2/locales/current`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Detect Best Language for User
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/locales/detect_best_locale(map<string|string[]> headers = {}) returns LocaleResponse|error {
        string resourcePath = string `/api/v2/locales/detect_best_locale`;
        return self.clientEp->get(resourcePath, headers);
    }

    resource isolated function get api/v2/locales/'public(map<string|string[]> headers = {}) returns LocalesResponse|error {
        string resourcePath = string `/api/v2/locales/public`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Macros
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros(ListMacrosHeaders headers = {}, *ListMacrosQueries queries) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Macro
    #
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function post api/v2/macros(V2MacrosBody payload, map<string|string[]> headers = {}) returns InlineResponse2002|error {
        string resourcePath = string `/api/v2/macros`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Macro
    #
    # + macro_id - The ID of the macro
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/[int macro_id](ShowMacroHeaders headers = {}) returns MacroResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Macro
    #
    # + macro_id - The ID of the macro
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function put api/v2/macros/[int macro_id](MacrosmacroIdBody payload, UpdateMacroHeaders headers = {}) returns InlineResponse2003|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Macro
    #
    # + macro_id - The ID of the macro
    # + headers - Headers to be sent with the request 
    # + return - No Content 
    resource isolated function delete api/v2/macros/[int macro_id](DeleteMacroHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Show Changes to Ticket
    #
    # + macro_id - The ID of the macro
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/[int macro_id]/apply(ShowChangesToTicketHeaders headers = {}) returns MacroApplyTicketResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}/apply`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Macro Attachments
    #
    # + macro_id - The ID of the macro
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/[int macro_id]/attachments(ListMacroAttachmentsHeaders headers = {}) returns MacroAttachmentsResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Macro Attachment
    #
    # + macro_id - The ID of the macro
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function post api/v2/macros/[int macro_id]/attachments(CreateAssociatedMacroAttachmentHeaders headers = {}) returns MacroAttachmentResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Supported Actions for Macros
    #
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/actions(map<string|string[]> headers = {}) returns InlineResponse2004|error {
        string resourcePath = string `/api/v2/macros/actions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Active Macros
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/active(ListActiveMacrosHeaders headers = {}, *ListActiveMacrosQueries queries) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros/active`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Unassociated Macro Attachment
    #
    # + headers - Headers to be sent with the request 
    # + return - Created Response 
    resource isolated function post api/v2/macros/attachments(map<string|string[]> headers = {}) returns MacroAttachmentResponse|error {
        string resourcePath = string `/api/v2/macros/attachments`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Macro Attachment
    #
    # + attachment_id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/attachments/[int attachment_id](ShowMacroAttachmentHeaders headers = {}) returns MacroAttachmentResponse|error {
        string resourcePath = string `/api/v2/macros/attachments/${getEncodedUri(attachment_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Macro Categories
    #
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/categories(map<string|string[]> headers = {}) returns MacroCategoriesResponse|error {
        string resourcePath = string `/api/v2/macros/categories`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Macro Action Definitions
    #
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/definitions(map<string|string[]> headers = {}) returns InlineResponse2005|error {
        string resourcePath = string `/api/v2/macros/definitions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk Delete Macros
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - No Content 
    resource isolated function delete api/v2/macros/destroy_many(DeleteManyMacrosHeaders headers = {}, *DeleteManyMacrosQueries queries) returns error? {
        string resourcePath = string `/api/v2/macros/destroy_many`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    resource isolated function get api/v2/macros/'new(ShowDerivedMacroHeaders headers = {}, *ShowDerivedMacroQueries queries) returns MacroResponse|error {
        string resourcePath = string `/api/v2/macros/new`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Search Macros
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/macros/search(SearchMacroHeaders headers = {}, *SearchMacroQueries queries) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Many Macros
    #
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function put api/v2/macros/update_many(MacroUpdateManyInput payload, map<string|string[]> headers = {}) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros/update_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Show Essentials Card
    #
    # + object_type - Essentials card type. Example: `zen:user` refers user type
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/object_layouts/[string object_type]/essentials_card(ShowEssentialsCardHeaders headers = {}) returns EssentialsCardResponse|error {
        string resourcePath = string `/api/v2/object_layouts/${getEncodedUri(object_type)}/essentials_card`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Essentials Card
    #
    # + object_type - Essentials card type. Example: `zen:user` refers user type
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/object_layouts/[string object_type]/essentials_card(UpdateEssentialsCardHeaders headers = {}) returns EssentialsCardResponse|error {
        string resourcePath = string `/api/v2/object_layouts/${getEncodedUri(object_type)}/essentials_card`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Essentials Card
    #
    # + object_type - Essentials card type. Example: `zen:user` refers user type
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/object_layouts/[string object_type]/essentials_card(DeleteEssentialsCardHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/object_layouts/${getEncodedUri(object_type)}/essentials_card`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List of Essentials Cards
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/object_layouts/essentials_cards(map<string|string[]> headers = {}) returns EssentialsCardsResponse|error {
        string resourcePath = string `/api/v2/object_layouts/essentials_cards`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Organization Fields
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organization_fields(map<string|string[]> headers = {}) returns OrganizationFieldsResponse|error {
        string resourcePath = string `/api/v2/organization_fields`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Organization Field
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/organization_fields(map<string|string[]> headers = {}) returns OrganizationFieldResponse|error {
        string resourcePath = string `/api/v2/organization_fields`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Organization Field
    #
    # + organization_field_id - The ID or key of the organization field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organization_fields/[organization_field_id organization_field_id](ShowOrganizationFieldHeaders headers = {}) returns OrganizationFieldResponse|error {
        string resourcePath = string `/api/v2/organization_fields/${getEncodedUri(organization_field_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Organization Field
    #
    # + organization_field_id - The ID or key of the organization field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/organization_fields/[organization_field_id organization_field_id](UpdateOrganizationFieldHeaders headers = {}) returns OrganizationFieldResponse|error {
        string resourcePath = string `/api/v2/organization_fields/${getEncodedUri(organization_field_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Organization Field
    #
    # + organization_field_id - The ID or key of the organization field
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/organization_fields/[organization_field_id organization_field_id](DeleteOrganizationFieldHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/organization_fields/${getEncodedUri(organization_field_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Reorder Organization Field
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/organization_fields/reorder(map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/organization_fields/reorder`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List Memberships
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organization_memberships(map<string|string[]> headers = {}) returns OrganizationMembershipsResponse|error {
        string resourcePath = string `/api/v2/organization_memberships`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Membership
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/organization_memberships(map<string|string[]> headers = {}) returns OrganizationMembershipResponse|error {
        string resourcePath = string `/api/v2/organization_memberships`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Membership
    #
    # + organization_membership_id - The ID of the organization membership
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organization_memberships/[int organization_membership_id](ShowOrganizationMembershipByIdHeaders headers = {}) returns OrganizationMembershipResponse|error {
        string resourcePath = string `/api/v2/organization_memberships/${getEncodedUri(organization_membership_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Membership
    #
    # + organization_membership_id - The ID of the organization membership
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/organization_memberships/[int organization_membership_id](DeleteOrganizationMembershipHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/organization_memberships/${getEncodedUri(organization_membership_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Create Many Memberships
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/organization_memberships/create_many(map<string|string[]> headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organization_memberships/create_many`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk Delete Memberships
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/organization_memberships/destroy_many(DeleteManyOrganizationMembershipsHeaders headers = {}, *DeleteManyOrganizationMembershipsQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organization_memberships/destroy_many`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Organization Subscriptions
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/organization_subscriptions(map<string|string[]> headers = {}) returns OrganizationSubscriptionsResponse|error {
        string resourcePath = string `/api/v2/organization_subscriptions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Organization Subscription
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/organization_subscriptions(OrganizationSubscriptionCreateRequest payload, map<string|string[]> headers = {}) returns OrganizationSubscriptionResponse|error {
        string resourcePath = string `/api/v2/organization_subscriptions`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Organization Subscription
    #
    # + organization_subscription_id - The ID of the organization subscription
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/organization_subscriptions/[int organization_subscription_id](ShowOrganizationSubscriptionHeaders headers = {}) returns OrganizationSubscriptionResponse|error {
        string resourcePath = string `/api/v2/organization_subscriptions/${getEncodedUri(organization_subscription_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Organization Subscription
    #
    # + organization_subscription_id - The ID of the organization subscription
    # + headers - Headers to be sent with the request 
    # + return - No content 
    resource isolated function delete api/v2/organization_subscriptions/[int organization_subscription_id](DeleteOrganizationSubscriptionHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/organization_subscriptions/${getEncodedUri(organization_subscription_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Organizations
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organizations(map<string|string[]> headers = {}) returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Organization
    #
    # + headers - Headers to be sent with the request 
    # + return - Created 
    resource isolated function post api/v2/organizations(map<string|string[]> headers = {}) returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Organization
    #
    # + organization_id - The ID of an organization
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organizations/[int organization_id](ShowOrganizationHeaders headers = {}) returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Organization
    #
    # + organization_id - The ID of an organization
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/organizations/[int organization_id](UpdateOrganizationHeaders headers = {}) returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Organization
    #
    # + organization_id - The ID of an organization
    # + headers - Headers to be sent with the request 
    # + return - No Content Response 
    resource isolated function delete api/v2/organizations/[int organization_id](DeleteOrganizationHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Show Organization's Related Information
    #
    # + organization_id - The ID of an organization
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organizations/[int organization_id]/related(OrganizationRelatedHeaders headers = {}) returns OrganizationsRelatedResponse|error {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}/related`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Autocomplete Organizations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organizations/autocomplete(AutocompleteOrganizationsHeaders headers = {}, *AutocompleteOrganizationsQueries queries) returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations/autocomplete`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Count Organizations
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organizations/count(map<string|string[]> headers = {}) returns CountOrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Many Organizations
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/organizations/create_many(map<string|string[]> headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organizations/create_many`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create Or Update Organization
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/organizations/create_or_update(map<string|string[]> headers = {}) returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/create_or_update`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk Delete Organizations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/organizations/destroy_many(DeleteManyOrganizationsHeaders headers = {}, *DeleteManyOrganizationsQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organizations/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Search Organizations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organizations/search(SearchOrganizationsHeaders headers = {}, *SearchOrganizationsQueries queries) returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Many Organizations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/organizations/show_many(ShowManyOrganizationsHeaders headers = {}, *ShowManyOrganizationsQueries queries) returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations/show_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Many Organizations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/organizations/update_many(UpdateManyOrganizationsHeaders headers = {}, *UpdateManyOrganizationsQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organizations/update_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Ticket Problems
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/problems(map<string|string[]> headers = {}) returns ListTicketProblemsResponse|error {
        string resourcePath = string `/api/v2/problems`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Autocomplete Problems
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/problems/autocomplete(ProblemsAutocompleteBody payload, AutocompleteProblemsHeaders headers = {}, *AutocompleteProblemsQueries queries) returns ListTicketProblemsResponse|error {
        string resourcePath = string `/api/v2/problems/autocomplete`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Bulk Unregister Push Notification Devices
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/push_notification_devices/destroy_many(PushNotificationDevicesRequest payload, map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/push_notification_devices/destroy_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List queues
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/queues(map<string|string[]> headers = {}) returns QueuesResponse|error {
        string resourcePath = string `/api/v2/queues`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create queue
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/queues(map<string|string[]> headers = {}) returns QueueResponse|error {
        string resourcePath = string `/api/v2/queues`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Queue
    #
    # + queue_id - The id of the omnichannel routing queue
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/queues/[string queue_id](ShowQueueByIdHeaders headers = {}) returns QueueResponse|error {
        string resourcePath = string `/api/v2/queues/${getEncodedUri(queue_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update queue
    #
    # + queue_id - The id of the omnichannel routing queue
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/queues/[string queue_id](UpdateQueueHeaders headers = {}) returns QueueResponse|error {
        string resourcePath = string `/api/v2/queues/${getEncodedUri(queue_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete queue
    #
    # + queue_id - The id of the omnichannel routing queue
    # + headers - Headers to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/queues/[string queue_id](DeleteQueueHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/queues/${getEncodedUri(queue_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List queue definitions
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/queues/definitions(map<string|string[]> headers = {}) returns DefinitionsResponse|error {
        string resourcePath = string `/api/v2/queues/definitions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Support Addresses
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/recipient_addresses(map<string|string[]> headers = {}) returns SupportAddressesResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Support Address
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/recipient_addresses(map<string|string[]> headers = {}) returns SupportAddressResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Support Address
    #
    # + support_address_id - The ID of the support address
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/recipient_addresses/[int support_address_id](ShowSupportAddressHeaders headers = {}) returns SupportAddressResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Support Address
    #
    # + support_address_id - The ID of the support address
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/recipient_addresses/[int support_address_id](UpdateSupportAddressHeaders headers = {}) returns SupportAddressResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Support Address
    #
    # + support_address_id - The ID of the support address
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/recipient_addresses/[int support_address_id](DeleteRecipientAddressHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Verify Support Address Forwarding
    #
    # + support_address_id - The ID of the support address
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/recipient_addresses/[int support_address_id]/verify(VerifySupportAddressForwardingHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}/verify`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Filter Definitions
    #
    # + targetType - The target type for which you would like to see filter definitions.
    # The options are "zen:user", "zen:ticket", "zen:organization", and "zen:custom_object:CUSTOM_OBJECT_KEY"
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/relationships/definitions/[string targetType](GetRelationshipFilterDefinitionsHeaders headers = {}, *GetRelationshipFilterDefinitionsQueries queries) returns RelationshipFilterDefinitionResponse|error {
        string resourcePath = string `/api/v2/relationships/definitions/${getEncodedUri(targetType)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Requests
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/requests(ListRequestsHeaders headers = {}, *ListRequestsQueries queries) returns RequestsResponse|error {
        string resourcePath = string `/api/v2/requests`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Request
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/requests(map<string|string[]> headers = {}) returns RequestResponse|error {
        string resourcePath = string `/api/v2/requests`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Request
    #
    # + request_id - The ID of the request
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/requests/[int request_id](ShowRequestHeaders headers = {}) returns RequestResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Request
    #
    # + request_id - The ID of the request
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/requests/[int request_id](UpdateRequestHeaders headers = {}) returns RequestResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Listing Comments
    #
    # + request_id - The ID of the request
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/requests/[int request_id]/comments(ListCommentsHeaders headers = {}, *ListCommentsQueries queries) returns TicketCommentsResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}/comments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Getting Comments
    #
    # + request_id - The ID of the request
    # + ticket_comment_id - The ID of the ticket comment
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/requests/[int request_id]/comments/[int ticket_comment_id](ShowCommentHeaders headers = {}) returns TicketCommentResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}/comments/${getEncodedUri(ticket_comment_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Search Requests
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/requests/search(SearchRequestsHeaders headers = {}, *SearchRequestsQueries queries) returns RequestsResponse|error {
        string resourcePath = string `/api/v2/requests/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Resource Collections
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/resource_collections(map<string|string[]> headers = {}) returns ResourceCollectionsResponse|error {
        string resourcePath = string `/api/v2/resource_collections`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Resource Collection
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/resource_collections(map<string|string[]> headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/resource_collections`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Resource Collection
    #
    # + resource_collection_id - The id of the resource collection
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/resource_collections/[int resource_collection_id](RetrieveResourceCollectionHeaders headers = {}) returns ResourceCollectionResponse|error {
        string resourcePath = string `/api/v2/resource_collections/${getEncodedUri(resource_collection_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Resource Collection
    #
    # + resource_collection_id - The id of the resource collection
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/resource_collections/[int resource_collection_id](UpdateResourceCollectionHeaders headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/resource_collections/${getEncodedUri(resource_collection_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Resource Collection
    #
    # + resource_collection_id - The id of the resource collection
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/resource_collections/[int resource_collection_id](DeleteResourceCollectionHeaders headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/resource_collections/${getEncodedUri(resource_collection_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Agent Attribute Values
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/agents/[int user_id]/instance_values(ListAGentAttributeValuesHeaders headers = {}) returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/agents/${getEncodedUri(user_id)}/instance_values`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set Agent Attribute Values
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/routing/agents/[int user_id]/instance_values(SetAgentAttributeValuesHeaders headers = {}) returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/agents/${getEncodedUri(user_id)}/instance_values`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Account Attributes
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/attributes(map<string|string[]> headers = {}) returns SkillBasedRoutingAttributesResponse|error {
        string resourcePath = string `/api/v2/routing/attributes`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Attribute
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/routing/attributes(map<string|string[]> headers = {}) returns SkillBasedRoutingAttributeResponse|error {
        string resourcePath = string `/api/v2/routing/attributes`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/attributes/[string attribute_id](ShowAttributeHeaders headers = {}) returns SkillBasedRoutingAttributeResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/routing/attributes/[string attribute_id](UpdateAttributeHeaders headers = {}) returns SkillBasedRoutingAttributeResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/routing/attributes/[string attribute_id](DeleteAttributeHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Attribute Values for an Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/attributes/[string attribute_id]/values(ListAttributeValuesHeaders headers = {}) returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/routing/attributes/[string attribute_id]/values(CreateAttributeValueHeaders headers = {}) returns SkillBasedRoutingAttributeValueResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Show Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + attribute_value_id - The ID of the skill-based routing attribute value
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/attributes/[string attribute_id]/values/[string attribute_value_id](ShowAttributeValueHeaders headers = {}) returns SkillBasedRoutingAttributeValueResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values/${getEncodedUri(attribute_value_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + attribute_value_id - The ID of the skill-based routing attribute value
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/routing/attributes/[string attribute_id]/values/[string attribute_value_id](DeleteAttributeValueHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values/${getEncodedUri(attribute_value_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Update Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + attribute_value_id - The ID of the skill-based routing attribute value
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function patch api/v2/routing/attributes/[string attribute_id]/values/[string attribute_value_id](UpdateAttributeValueHeaders headers = {}) returns SkillBasedRoutingAttributeValueResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values/${getEncodedUri(attribute_value_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # List Routing Attribute Definitions
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/attributes/definitions(map<string|string[]> headers = {}) returns SkillBasedRoutingAttributeDefinitions|error {
        string resourcePath = string `/api/v2/routing/attributes/definitions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Tickets Fulfilled by a User
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/requirements/fulfilled(ListTicketsFullfilledByUserHeaders headers = {}, *ListTicketsFullfilledByUserQueries queries) returns SkillBasedRoutingTicketFulfilledResponse|error {
        string resourcePath = string `/api/v2/routing/requirements/fulfilled`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Ticket Attribute Values
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/routing/tickets/[int ticket_id]/instance_values(ListTicketAttributeValuesHeaders headers = {}) returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/tickets/${getEncodedUri(ticket_id)}/instance_values`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set Ticket Attribute Values
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/routing/tickets/[int ticket_id]/instance_values(SetTicketAttributeValuesHeaders headers = {}) returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/tickets/${getEncodedUri(ticket_id)}/instance_values`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Satisfaction Ratings
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/satisfaction_ratings(ListSatisfactionRatingsHeaders headers = {}) returns SatisfactionRatingsResponse|error {
        string resourcePath = string `/api/v2/satisfaction_ratings`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Satisfaction Rating
    #
    # + satisfactionRatingId - The id of the satisfaction rating to retrieve
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/satisfaction_ratings/[int satisfactionRatingId](ShowSatisfactionRatingHeaders headers = {}) returns SatisfactionRatingResponse|error {
        string resourcePath = string `/api/v2/satisfaction_ratings/${getEncodedUri(satisfactionRatingId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Count Satisfaction Ratings
    #
    # + headers - Headers to be sent with the request 
    # + return - Count of satisfaction ratings 
    resource isolated function get api/v2/satisfaction_ratings/count(map<string|string[]> headers = {}) returns SatisfactionRatingsCountResponse|error {
        string resourcePath = string `/api/v2/satisfaction_ratings/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Reasons for Satisfaction Rating
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/satisfaction_reasons(map<string|string[]> headers = {}) returns SatisfactionReasonsResponse|error {
        string resourcePath = string `/api/v2/satisfaction_reasons`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Reason for Satisfaction Rating
    #
    # + satisfactionReasonId - The id of the satisfaction rating reason
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/satisfaction_reasons/[int satisfactionReasonId](ShowSatisfactionRatingsHeaders headers = {}) returns SatisfactionReasonResponse|error {
        string resourcePath = string `/api/v2/satisfaction_reasons/${getEncodedUri(satisfactionReasonId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Search Results
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/search(ListSearchResultsHeaders headers = {}, *ListSearchResultsQueries queries) returns SearchResponse|error {
        string resourcePath = string `/api/v2/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Results Count
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/search/count(CountSearchResultsHeaders headers = {}, *CountSearchResultsQueries queries) returns SearchCountResponse|error {
        string resourcePath = string `/api/v2/search/count`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Export Search Results
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/search/export(ExportSearchResultsHeaders headers = {}, *ExportSearchResultsQueries queries) returns SearchExportResponse|error {
        string resourcePath = string `/api/v2/search/export`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Sessions
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/sessions(ListSessionsHeaders headers = {}) returns SessionsResponse|error {
        string resourcePath = string `/api/v2/sessions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Sharing Agreements
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/sharing_agreements(map<string|string[]> headers = {}) returns SharingAgreementsResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Sharing Agreement
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/sharing_agreements(map<string|string[]> headers = {}) returns SharingAgreementResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show a Sharing Agreement
    #
    # + sharing_agreement_id - The ID of the sharing agreement
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/sharing_agreements/[int sharing_agreement_id](ShowSharingAgreementHeaders headers = {}) returns SharingAgreementResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements/${getEncodedUri(sharing_agreement_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update a Sharing Agreement
    #
    # + sharing_agreement_id - The ID of the sharing agreement
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/sharing_agreements/[int sharing_agreement_id](UpdateSharingAgreementHeaders headers = {}) returns SharingAgreementResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements/${getEncodedUri(sharing_agreement_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete a Sharing Agreement
    #
    # + sharing_agreement_id - The ID of the sharing agreement
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/sharing_agreements/[int sharing_agreement_id](DeleteSharingAgreementHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/sharing_agreements/${getEncodedUri(sharing_agreement_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Record a New Skip for the Current User
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/skips(map<string|string[]> headers = {}) returns TicketSkipCreation|error {
        string resourcePath = string `/api/v2/skips`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List SLA Policies
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/slas/policies(map<string|string[]> headers = {}) returns SLAPoliciesResponse|error {
        string resourcePath = string `/api/v2/slas/policies`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create SLA Policy
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/slas/policies(map<string|string[]> headers = {}) returns SLAPolicyResponse|error {
        string resourcePath = string `/api/v2/slas/policies`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show SLA Policy
    #
    # + sla_policy_id - The ID of the SLA Policy
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/slas/policies/[int sla_policy_id](ShowSLAPolicyHeaders headers = {}) returns SLAPolicyResponse|error {
        string resourcePath = string `/api/v2/slas/policies/${getEncodedUri(sla_policy_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update SLA Policy
    #
    # + sla_policy_id - The ID of the SLA Policy
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/slas/policies/[int sla_policy_id](UpdateSLAPolicyHeaders headers = {}) returns SLAPolicyResponse|error {
        string resourcePath = string `/api/v2/slas/policies/${getEncodedUri(sla_policy_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete SLA Policy
    #
    # + sla_policy_id - The ID of the SLA Policy
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/slas/policies/[int sla_policy_id](DeleteSLAPolicyHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/slas/policies/${getEncodedUri(sla_policy_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Retrieve Supported Filter Definition Items
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/slas/policies/definitions(map<string|string[]> headers = {}) returns SLAPolicyFilterDefinitionResponse|error {
        string resourcePath = string `/api/v2/slas/policies/definitions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Reorder SLA Policies
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/slas/policies/reorder(ReorderSLAPoliciesHeaders headers = {}, *ReorderSLAPoliciesQueries queries) returns string|error {
        string resourcePath = string `/api/v2/slas/policies/reorder`;
        map<Encoding> queryParamEncoding = {"sla_policy_ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Suspended Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/suspended_tickets(ListSuspendedTicketsHeaders headers = {}, *ListSuspendedTicketsQueries queries) returns SuspendedTicketsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Suspended Ticket
    #
    # + id - id of the suspended ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/suspended_tickets/[decimal id](ShowSuspendedTicketsHeaders headers = {}) returns SuspendedTicketsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/${getEncodedUri(id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Suspended Ticket
    #
    # + id - id of the suspended ticket
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/suspended_tickets/[decimal id](DeleteSuspendedTicketHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/suspended_tickets/${getEncodedUri(id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Recover Suspended Ticket
    #
    # + id - id of the suspended ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/suspended_tickets/[decimal id]/recover(RecoverSuspendedTicketHeaders headers = {}) returns RecoverSuspendedTicketResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/${getEncodedUri(id)}/recover`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Suspended Ticket Attachments
    #
    # + id - id of the suspended ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/suspended_tickets/attachments(SuspendedTicketsAttachmentsHeaders headers = {}) returns SuspendedTicketsAttachmentsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/attachments`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Delete Multiple Suspended Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/suspended_tickets/destroy_many(DeleteSuspendedTicketsHeaders headers = {}, *DeleteSuspendedTicketsQueries queries) returns error? {
        string resourcePath = string `/api/v2/suspended_tickets/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Export Suspended Tickets
    #
    # + headers - Headers to be sent with the request 
    # + return - Ok 
    resource isolated function post api/v2/suspended_tickets/export(map<string|string[]> headers = {}) returns SuspendedTicketsExportResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/export`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Recover Multiple Suspended Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/suspended_tickets/recover_many(RecoverSuspendedTicketsHeaders headers = {}, *RecoverSuspendedTicketsQueries queries) returns RecoverSuspendedTicketsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/recover_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Tags
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/tags(map<string|string[]> headers = {}) returns TagsResponse|error {
        string resourcePath = string `/api/v2/tags`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Count Tags
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/tags/count(map<string|string[]> headers = {}) returns TagCountResponse|error {
        string resourcePath = string `/api/v2/tags/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Target Failures
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/target_failures(map<string|string[]> headers = {}) returns TargetFailuresResponse|error {
        string resourcePath = string `/api/v2/target_failures`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Target Failure
    #
    # + target_failure_id - The ID of the target failure
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/target_failures/[int target_failure_id](ShowTargetFailureHeaders headers = {}) returns TargetFailureResponse|error {
        string resourcePath = string `/api/v2/target_failures/${getEncodedUri(target_failure_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Targets
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/targets(map<string|string[]> headers = {}) returns TargetsResponse|error {
        string resourcePath = string `/api/v2/targets`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Target
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/targets(map<string|string[]> headers = {}) returns TargetResponse|error {
        string resourcePath = string `/api/v2/targets`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Target
    #
    # + target_id - The ID of the target
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/targets/[int target_id](ShowTargetHeaders headers = {}) returns TargetResponse|error {
        string resourcePath = string `/api/v2/targets/${getEncodedUri(target_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Target
    #
    # + target_id - The ID of the target
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/targets/[int target_id](UpdateTargetHeaders headers = {}) returns TargetResponse|error {
        string resourcePath = string `/api/v2/targets/${getEncodedUri(target_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Target
    #
    # + target_id - The ID of the target
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/targets/[int target_id](DeleteTargetHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/targets/${getEncodedUri(target_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List All Ticket Audits
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_audits(ListTicketAuditsHeaders headers = {}, *ListTicketAuditsQueries queries) returns TicketAuditsResponse|error {
        string resourcePath = string `/api/v2/ticket_audits`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Ticket Fields
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_fields(ListTicketFieldsHeaders headers = {}, *ListTicketFieldsQueries queries) returns TicketFieldsResponse|error {
        string resourcePath = string `/api/v2/ticket_fields`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Ticket Field
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/ticket_fields(map<string|string[]> headers = {}) returns TicketFieldResponse|error {
        string resourcePath = string `/api/v2/ticket_fields`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Ticket Field
    #
    # + ticket_field_id - The ID of the ticket field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_fields/[int ticket_field_id](ShowTicketfieldHeaders headers = {}, *ShowTicketfieldQueries queries) returns TicketFieldResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Ticket Field
    #
    # + ticket_field_id - The ID of the ticket field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/ticket_fields/[int ticket_field_id](UpdateTicketFieldHeaders headers = {}, *UpdateTicketFieldQueries queries) returns TicketFieldResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Ticket Field
    #
    # + ticket_field_id - The ID of the ticket field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/ticket_fields/[int ticket_field_id](DeleteTicketFieldHeaders headers = {}, *DeleteTicketFieldQueries queries) returns error? {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Ticket Field Options
    #
    # + ticket_field_id - The ID of the ticket field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_fields/[int ticket_field_id]/options(ListTicketFieldOptionsHeaders headers = {}) returns CustomFieldOptionsResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create or Update Ticket Field Option
    #
    # + ticket_field_id - The ID of the ticket field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/ticket_fields/[int ticket_field_id]/options(CreateOrUpdateTicketFieldOptionHeaders headers = {}) returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Show Ticket Field Option
    #
    # + ticket_field_id - The ID of the ticket field
    # + ticket_field_option_id - The ID of the ticket field option
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_fields/[int ticket_field_id]/options/[int ticket_field_option_id](ShowTicketFieldOptionHeaders headers = {}) returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options/${getEncodedUri(ticket_field_option_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Ticket Field Option
    #
    # + ticket_field_id - The ID of the ticket field
    # + ticket_field_option_id - The ID of the ticket field option
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/ticket_fields/[int ticket_field_id]/options/[int ticket_field_option_id](DeleteTicketFieldOptionHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options/${getEncodedUri(ticket_field_option_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Count Ticket Fields
    #
    # + headers - Headers to be sent with the request 
    # + return - Count of ticket fields 
    resource isolated function get api/v2/ticket_fields/count(map<string|string[]> headers = {}) returns TicketFieldCountResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List Ticket Forms
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_forms(ListTicketFormsHeaders headers = {}, *ListTicketFormsQueries queries) returns TicketFormsResponse|error {
        string resourcePath = string `/api/v2/ticket_forms`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Ticket Form
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/ticket_forms(map<string|string[]> headers = {}) returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_forms/[int ticket_form_id](ShowTicketFormHeaders headers = {}) returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/ticket_forms/[int ticket_form_id](UpdateTicketFormHeaders headers = {}) returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/ticket_forms/[int ticket_form_id](DeleteTicketFormHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Clone an Already Existing Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/ticket_forms/[int ticket_form_id]/clone(CloneTicketFormHeaders headers = {}) returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}/clone`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Reorder Ticket Forms
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/ticket_forms/reorder(map<string|string[]> headers = {}) returns TicketFormsResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/reorder`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Show Many Ticket Forms
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_forms/show_many(ShowManyTicketFormsHeaders headers = {}, *ShowManyTicketFormsQueries queries) returns TicketFormsResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/show_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Ticket Metrics
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_metrics(map<string|string[]> headers = {}) returns TicketMetricsResponse|error {
        string resourcePath = string `/api/v2/ticket_metrics`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Show Ticket Metrics
    #
    # + ticketMetricId - The id of the ticket metric to retrieve
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/ticket_metrics/[string ticketMetricId](ShowTicketMetricsHeaders headers = {}) returns TicketMetricsByTicketMetricIdResponse|error {
        string resourcePath = string `/api/v2/ticket_metrics/${getEncodedUri(ticketMetricId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List tickets 
    resource isolated function get api/v2/tickets(ListTicketsHeaders headers = {}, *ListTicketsQueries queries) returns TicketsResponse|error {
        string resourcePath = string `/api/v2/tickets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Ticket
    #
    # + headers - Headers to be sent with the request 
    # + return - Create ticket 
    resource isolated function post api/v2/tickets(TicketCreateRequest payload, map<string|string[]> headers = {}) returns TicketResponse|error {
        string resourcePath = string `/api/v2/tickets`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Ticket 
    resource isolated function get api/v2/tickets/[int ticket_id](ShowTicketHeaders headers = {}) returns TicketResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful request 
    resource isolated function put api/v2/tickets/[int ticket_id](TicketUpdateRequest payload, UpdateTicketHeaders headers = {}) returns TicketUpdateResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - No content 
    resource isolated function delete api/v2/tickets/[int ticket_id](DeleteTicketHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Audits for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - OK response 
    resource isolated function get api/v2/tickets/[int ticket_id]/audits(ListAuditsForTicketHeaders headers = {}) returns TicketAuditsResponseNoneCursor|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Audit
    #
    # + ticket_id - The ID of the ticket
    # + ticket_audit_id - The ID of the ticket audit
    # + headers - Headers to be sent with the request 
    # + return - OK response 
    resource isolated function get api/v2/tickets/[int ticket_id]/audits/[int ticket_audit_id](ShowTicketAuditHeaders headers = {}) returns TicketAuditResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits/${getEncodedUri(ticket_audit_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Change a Comment From Public To Private
    #
    # + ticket_id - The ID of the ticket
    # + ticket_audit_id - The ID of the ticket audit
    # + headers - Headers to be sent with the request 
    # + return - description 
    resource isolated function put api/v2/tickets/[int ticket_id]/audits/[int ticket_audit_id]/make_private(MakeTicketCommentPrivateFromAuditsHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits/${getEncodedUri(ticket_audit_id)}/make_private`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Count Audits for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Count of audits on a ticket 
    resource isolated function get api/v2/tickets/[int ticket_id]/audits/count(CountAuditsForTicketHeaders headers = {}) returns TicketAuditsCountResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits/count`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Collaborators for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/tickets/[int ticket_id]/collaborators(ListTicketCollaboratorsHeaders headers = {}) returns ListTicketCollaboratorsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/collaborators`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Comments
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/tickets/[int ticket_id]/comments(ListTicketCommentsHeaders headers = {}, *ListTicketCommentsQueries queries) returns TicketCommentsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Redact Comment Attachment
    #
    # + ticket_id - The ID of the ticket
    # + comment_id - The ID of the comment
    # + attachment_id - The ID of the attachment
    # + headers - Headers to be sent with the request 
    # + return - OK response 
    resource isolated function put api/v2/tickets/[int ticket_id]/comments/[int comment_id]/attachments/[int attachment_id]/redact(RedactCommentAttachmentHeaders headers = {}) returns AttachmentResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/${getEncodedUri(comment_id)}/attachments/${getEncodedUri(attachment_id)}/redact`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Make Comment Private
    #
    # + ticket_id - The ID of the ticket
    # + ticket_comment_id - The ID of the ticket comment
    # + headers - Headers to be sent with the request 
    # + return - description 
    resource isolated function put api/v2/tickets/[int ticket_id]/comments/[int ticket_comment_id]/make_private(MakeTicketCommentPrivateHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/${getEncodedUri(ticket_comment_id)}/make_private`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Redact String in Comment
    #
    # + ticket_id - The ID of the ticket
    # + ticket_comment_id - The ID of the ticket comment
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/tickets/[int ticket_id]/comments/[int ticket_comment_id]/redact(RedactStringInCommentHeaders headers = {}) returns TicketCommentResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/${getEncodedUri(ticket_comment_id)}/redact`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Count Ticket Comments
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Count of ticket comments 
    resource isolated function get api/v2/tickets/[int ticket_id]/comments/count(CountTicketCommentsHeaders headers = {}) returns TicketCommentsCountResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/count`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Email CCs for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/tickets/[int ticket_id]/email_ccs(ListTicketEmailCCsHeaders headers = {}) returns ListTicketEmailCCsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/email_ccs`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Followers for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/tickets/[int ticket_id]/followers(ListTicketFollowersHeaders headers = {}) returns ListTicketFollowersResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/followers`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Ticket Incidents
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/tickets/[int ticket_id]/incidents(ListTicketIncidentsHeaders headers = {}) returns ListTicketIncidentsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/incidents`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Ticket After Changes
    #
    # + macro_id - The ID of the macro
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/tickets/[int ticket_id]/macros/[int macro_id]/apply(ShowTicketAfterChangesHeaders headers = {}) returns MacroApplyTicketResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/macros/${getEncodedUri(macro_id)}/apply`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Mark Ticket as Spam and Suspend Requester
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function put api/v2/tickets/[int ticket_id]/mark_as_spam(MarkTicketAsSpamAndSuspendRequesterHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/mark_as_spam`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Merge Tickets into Target Ticket
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function post api/v2/tickets/[int ticket_id]/merge(TicketMergeInput payload, MergeTicketsIntoTargetTicketHeaders headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/merge`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Ticket Related Information
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/tickets/[int ticket_id]/related(TicketRelatedInformationHeaders headers = {}) returns TicketRelatedInformation|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/related`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create a Satisfaction Rating
    #
    # + ticket_id - The id of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/tickets/[int ticket_id]/satisfaction_rating(CreateTicketSatisfactionRatingHeaders headers = {}) returns SatisfactionRatingResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/satisfaction_rating`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List Resource Tags
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/tickets/[int ticket_id]/tags(ListResourceTagsHeaders headers = {}) returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Add Tags
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/tickets/[int ticket_id]/tags(PutTagsTicketHeaders headers = {}) returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Set Tags
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/tickets/[int ticket_id]/tags(SetTagsTicketHeaders headers = {}) returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Remove Tags
    #
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/tickets/[int ticket_id]/tags(DeleteTagsTicketHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Count Tickets
    #
    # + headers - Headers to be sent with the request 
    # + return - Count of tickets 
    resource isolated function get api/v2/tickets/count(map<string|string[]> headers = {}) returns InlineResponse2006|error {
        string resourcePath = string `/api/v2/tickets/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Many Tickets
    #
    # + headers - Headers to be sent with the request 
    # + return - Create many tickets 
    resource isolated function post api/v2/tickets/create_many(TicketsCreateRequest payload, map<string|string[]> headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/create_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk Delete Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function delete api/v2/tickets/destroy_many(BulkDeleteTicketsHeaders headers = {}, *BulkDeleteTicketsQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Bulk Mark Tickets as Spam
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function put api/v2/tickets/mark_many_as_spam(MarkManyTicketsAsSpamHeaders headers = {}, *MarkManyTicketsAsSpamQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/mark_many_as_spam`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Show Multiple Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List tickets 
    resource isolated function get api/v2/tickets/show_many(TicketsShowManyHeaders headers = {}, *TicketsShowManyQueries queries) returns TicketsResponse|error {
        string resourcePath = string `/api/v2/tickets/show_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Many Tickets
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function put api/v2/tickets/update_many(TicketsUpdateManyHeaders headers = {}, *TicketsUpdateManyQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/update_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Trigger Categories
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - A paged array of trigger categories 
    resource isolated function get api/v2/trigger_categories(ListTriggerCategoriesHeaders headers = {}, *ListTriggerCategoriesQueries queries) returns InlineResponse2007|error {
        string resourcePath = string `/api/v2/trigger_categories`;
        map<Encoding> queryParamEncoding = {"page": {style: DEEPOBJECT, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Trigger Category
    #
    # + headers - Headers to be sent with the request 
    # + return - The created trigger category 
    resource isolated function post api/v2/trigger_categories(V2TriggerCategoriesBody payload, map<string|string[]> headers = {}) returns TriggerCategoryResponse|error {
        string resourcePath = string `/api/v2/trigger_categories`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Trigger Category
    #
    # + triggerCategoryId - The id of the trigger category to retrieve
    # + headers - Headers to be sent with the request 
    # + return - The requested trigger category 
    resource isolated function get api/v2/trigger_categories/[string triggerCategoryId](ShowTriggerCategoryByIdHeaders headers = {}) returns TriggerCategoryResponse|error {
        string resourcePath = string `/api/v2/trigger_categories/${getEncodedUri(triggerCategoryId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Trigger Category
    #
    # + triggerCategoryId - The id of the trigger category to delete
    # + headers - Headers to be sent with the request 
    # + return - No content 
    resource isolated function delete api/v2/trigger_categories/[string triggerCategoryId](DeleteTriggerCategoryHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/trigger_categories/${getEncodedUri(triggerCategoryId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Update Trigger Category
    #
    # + triggerCategoryId - The id of the trigger category to update
    # + headers - Headers to be sent with the request 
    # + return - The updated trigger category 
    resource isolated function patch api/v2/trigger_categories/[string triggerCategoryId](TriggerCategoriestriggerCategoryIdBody payload, UpdateTriggerCategoryHeaders headers = {}) returns TriggerCategoryResponse|error {
        string resourcePath = string `/api/v2/trigger_categories/${getEncodedUri(triggerCategoryId)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, httpHeaders);
    }

    # Create Batch Job for Trigger Categories
    #
    # + headers - Headers to be sent with the request 
    # + return - The response to the batch job 
    resource isolated function post api/v2/trigger_categories/jobs(BatchJobRequest payload, map<string|string[]> headers = {}) returns BatchJobResponse|error {
        string resourcePath = string `/api/v2/trigger_categories/jobs`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List Triggers
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/triggers(ListTriggersHeaders headers = {}, *ListTriggersQueries queries) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Trigger
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/triggers(TriggerWithCategoryRequest payload, map<string|string[]> headers = {}) returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Trigger
    #
    # + trigger_id - The ID of the trigger
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/triggers/[int trigger_id](GetTriggerHeaders headers = {}) returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Trigger
    #
    # + trigger_id - The ID of the trigger
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/triggers/[int trigger_id](TriggerWithCategoryRequest payload, UpdateTriggerHeaders headers = {}) returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Trigger
    #
    # + trigger_id - The ID of the trigger
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/triggers/[int trigger_id](DeleteTriggerHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Trigger Revisions
    #
    # + trigger_id - The ID of the trigger
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/triggers/[int trigger_id]/revisions(ListTriggerRevisionsHeaders headers = {}) returns TriggerRevisionsResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}/revisions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Trigger Revision
    #
    # + trigger_id - The ID of the trigger
    # + trigger_revision_id - The ID of the revision for a particular trigger
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/triggers/[int trigger_id]/revisions/[int trigger_revision_id](TriggerRevisionHeaders headers = {}) returns TriggerRevisionResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}/revisions/${getEncodedUri(trigger_revision_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Active Triggers
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/triggers/active(ListActiveTriggersHeaders headers = {}, *ListActiveTriggersQueries queries) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers/active`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Trigger Action and Condition Definitions
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/triggers/definitions(map<string|string[]> headers = {}) returns TriggerDefinitionResponse|error {
        string resourcePath = string `/api/v2/triggers/definitions`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Bulk Delete Triggers
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - No content response 
    resource isolated function delete api/v2/triggers/destroy_many(DeleteManyTriggersHeaders headers = {}, *DeleteManyTriggersQueries queries) returns error? {
        string resourcePath = string `/api/v2/triggers/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Reorder Triggers
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/triggers/reorder(map<string|string[]> headers = {}) returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers/reorder`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Search Triggers
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/triggers/search(SearchTriggersHeaders headers = {}, *SearchTriggersQueries queries) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers/search`;
        map<Encoding> queryParamEncoding = {"filter": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Many Triggers
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/triggers/update_many(TriggerBulkUpdateRequest payload, map<string|string[]> headers = {}) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers/update_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Upload Files
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/uploads(map<string|string[]> headers = {}) returns AttachmentUploadResponse|error {
        string resourcePath = string `/api/v2/uploads`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete Upload
    #
    # + token - The token of the uploaded attachment
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/uploads/[string token](DeleteUploadHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/uploads/${getEncodedUri(token)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List User Fields
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/user_fields(map<string|string[]> headers = {}) returns UserFieldsResponse|error {
        string resourcePath = string `/api/v2/user_fields`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create User Field
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/user_fields(map<string|string[]> headers = {}) returns UserFieldResponse|error {
        string resourcePath = string `/api/v2/user_fields`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show User Field
    #
    # + user_field_id - The ID or key of the user field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/user_fields/[user_field_id user_field_id](ShowUserFieldHeaders headers = {}) returns UserFieldResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update User Field
    #
    # + user_field_id - The ID or key of the user field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/user_fields/[user_field_id user_field_id](UpdateUserFieldHeaders headers = {}) returns UserFieldResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete User Field
    #
    # + user_field_id - The ID or key of the user field
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/user_fields/[user_field_id user_field_id](DeleteUserFieldHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List User Field Options
    #
    # + user_field_id - The ID or key of the user field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/user_fields/[user_field_id user_field_id]/options(ListUserFieldOptionsHeaders headers = {}) returns CustomFieldOptionsResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create or Update a User Field Option
    #
    # + user_field_id - The ID or key of the user field
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/user_fields/[user_field_id user_field_id]/options(CreateOrUpdateUserFieldOptionHeaders headers = {}) returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Show a User Field Option
    #
    # + user_field_id - The ID or key of the user field
    # + user_field_option_id - The ID of the user field option
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/user_fields/[user_field_id user_field_id]/options/[int user_field_option_id](ShowUserFieldOptionHeaders headers = {}) returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options/${getEncodedUri(user_field_option_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete User Field Option
    #
    # + user_field_id - The ID or key of the user field
    # + user_field_option_id - The ID of the user field option
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/user_fields/[user_field_id user_field_id]/options/[int user_field_option_id](DeleteUserFieldOptionHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options/${getEncodedUri(user_field_option_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Reorder User Field
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/user_fields/reorder(map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/user_fields/reorder`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users(ListUsersHeaders headers = {}, *ListUsersQueries queries) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create User
    #
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/users(UserRequest payload, map<string|string[]> headers = {}) returns UserResponse|error {
        string resourcePath = string `/api/v2/users`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show User
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id](ShowUserHeaders headers = {}) returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update User
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id](UserRequest payload, UpdateUserHeaders headers = {}) returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete User
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/users/[int user_id](DeleteUserHeaders headers = {}) returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Show Compliance Deletion Statuses
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/compliance_deletion_statuses(ShowUserComplianceDeletionStatusesHeaders headers = {}, *ShowUserComplianceDeletionStatusesQueries queries) returns ComplianceDeletionStatusesResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/compliance_deletion_statuses`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Memberships
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/group_memberships(ListGroupMembershipsByUserIdHeaders headers = {}) returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/group_memberships`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Set Membership as Default
    #
    # + user_id - The id of the user
    # + group_membership_id - The ID of the group membership
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id]/group_memberships/[int group_membership_id]/make_default(GroupMembershipSetDefaultHeaders headers = {}) returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/group_memberships/${getEncodedUri(group_membership_id)}/make_default`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Identities
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/identities(ListUserIdentitiesHeaders headers = {}) returns UserIdentitiesResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Identity
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Created response 
    resource isolated function post api/v2/users/[int user_id]/identities(CreateUserIdentityHeaders headers = {}) returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Show Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/identities/[int user_identity_id](ShowUserIdentityHeaders headers = {}) returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id](UpdateUserIdentityHeaders headers = {}) returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/users/[int user_id]/identities/[int user_identity_id](DeleteUserIdentityHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Make Identity Primary
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id]/make_primary(MakeUserIdentityPrimaryHeaders headers = {}) returns UserIdentitiesResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}/make_primary`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Request User Verification
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + headers - Headers to be sent with the request 
    # + return - Success description 
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id]/request_verification(RequestUserVerficationHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}/request_verification`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Verify Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id]/verify(VerifyUserIdentityHeaders headers = {}) returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}/verify`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Merge End Users
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id]/merge(UserRequest payload, MergeEndUsersHeaders headers = {}) returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/merge`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Set Membership as Default
    #
    # + user_id - The id of the user
    # + organization_membership_id - The ID of the organization membership
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id]/organization_memberships/[int organization_membership_id]/make_default(SetOrganizationMembershipAsDefaultHeaders headers = {}) returns OrganizationMembershipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/organization_memberships/${getEncodedUri(organization_membership_id)}/make_default`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Unassign Organization
    #
    # + organization_id - The ID of an organization
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/users/[int user_id]/organizations/[int organization_id](UnassignOrganizationHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/organizations/${getEncodedUri(organization_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Set Organization as Default
    #
    # + user_id - The id of the user
    # + organization_id - The ID of an organization
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/users/[int user_id]/organizations/[int organization_id]/make_default(SetOrganizationAsDefaultHeaders headers = {}) returns OrganizationMembershipResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/organizations/${getEncodedUri(organization_id)}/make_default`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Change Your Password
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success description 
    resource isolated function put api/v2/users/[int user_id]/password(ChangeOwnPasswordHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/password`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Set a User's Password
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success description 
    resource isolated function post api/v2/users/[int user_id]/password(SetUserPasswordHeaders headers = {}) returns string|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/password`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # List password requirements
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/password/requirements(GetUserPasswordRequirementsHeaders headers = {}) returns UserPasswordRequirementsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/password/requirements`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show User Related Information
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/related(ShowUserRelatedHeaders headers = {}) returns UserRelatedResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/related`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Bulk Delete Sessions
    #
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - No Content 
    resource isolated function delete api/v2/users/[int user_id]/sessions(BulkDeleteSessionsByUserIdHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/sessions`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Show Session
    #
    # + session_id - The ID of the session
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/sessions/[int session_id](ShowSessionHeaders headers = {}) returns SessionResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/sessions/${getEncodedUri(session_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Delete Session
    #
    # + session_id - The ID of the session
    # + user_id - The id of the user
    # + headers - Headers to be sent with the request 
    # + return - No Content 
    resource isolated function delete api/v2/users/[int user_id]/sessions/[int session_id](DeleteSessionHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/sessions/${getEncodedUri(session_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # List Ticket Skips
    #
    # + user_id - User ID of an agent
    # + ticket_id - The ID of the ticket
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/[int user_id]/skips(ListTicketSkipsHeaders headers = {}, *ListTicketSkipsQueries queries) returns TicketSkipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/skips`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Autocomplete Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/autocomplete(AutocompleteUsersHeaders headers = {}, *AutocompleteUsersQueries queries) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users/autocomplete`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Count Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/count(CountUsersHeaders headers = {}, *CountUsersQueries queries) returns CountResponse|error {
        string resourcePath = string `/api/v2/users/count`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create Many Users
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/users/create_many(UsersRequest payload, map<string|string[]> headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/create_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create Or Update User
    #
    # + headers - Headers to be sent with the request 
    # + return - Successful response, when user exits 
    resource isolated function post api/v2/users/create_or_update(UserRequest payload, map<string|string[]> headers = {}) returns UserResponse|error {
        string resourcePath = string `/api/v2/users/create_or_update`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create Or Update Many Users
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/users/create_or_update_many(UsersRequest payload, map<string|string[]> headers = {}) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/create_or_update_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Bulk Delete Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function delete api/v2/users/destroy_many(DestroyManyUsersHeaders headers = {}, *DestroyManyUsersQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Logout many users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Accepted response 
    resource isolated function post api/v2/users/logout_many(LogoutManyUsersHeaders headers = {}, *LogoutManyUsersQueries queries) returns string|error {
        string resourcePath = string `/api/v2/users/logout_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Show Self
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/me(map<string|string[]> headers = {}) returns CurrentUserResponse|error {
        string resourcePath = string `/api/v2/users/me`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete the Authenticated Session
    #
    # + headers - Headers to be sent with the request 
    # + return - No Content 
    resource isolated function delete api/v2/users/me/logout(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/api/v2/users/me/logout`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Show the Currently Authenticated Session
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/me/session(map<string|string[]> headers = {}) returns SessionResponse|error {
        string resourcePath = string `/api/v2/users/me/session`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Renew the current session
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/me/session/renew(map<string|string[]> headers = {}) returns RenewSessionResponse|error {
        string resourcePath = string `/api/v2/users/me/session/renew`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Request User Create
    #
    # + headers - Headers to be sent with the request 
    # + return - description 
    resource isolated function post api/v2/users/request_create(UserRequest payload, map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/users/request_create`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/search(SearchUsersHeaders headers = {}, *SearchUsersQueries queries) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Show Many Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/users/show_many(ShowManyUsersHeaders headers = {}, *ShowManyUsersQueries queries) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users/show_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Many Users
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Successful response 
    resource isolated function put api/v2/users/update_many(UsersUpdateManyBody payload, UpdateManyUsersHeaders headers = {}, *UpdateManyUsersQueries queries) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/update_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # List Views
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views(ListViewsHeaders headers = {}, *ListViewsQueries queries) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Create View
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/views(map<string|string[]> headers = {}) returns ViewResponse|error {
        string resourcePath = string `/api/v2/views`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show View
    #
    # + view_id - The ID of the view
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/[int view_id](ShowViewHeaders headers = {}) returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update View
    #
    # + view_id - The ID of the view
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/views/[int view_id](UpdateViewHeaders headers = {}) returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete View
    #
    # + view_id - The ID of the view
    # + headers - Headers to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/views/[int view_id](DeleteViewHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Count Tickets in View
    #
    # + view_id - The ID of the view
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/[int view_id]/count(GetViewCountHeaders headers = {}) returns ViewCountResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/count`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Execute View
    #
    # + view_id - The ID of the view
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/[int view_id]/execute(ExecuteViewHeaders headers = {}, *ExecuteViewQueries queries) returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/execute`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Export View
    #
    # + view_id - The ID of the view
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/[int view_id]/export(ExportViewHeaders headers = {}) returns ViewExportResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/export`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Tickets From a View
    #
    # + view_id - The ID of the view
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/[int view_id]/tickets(ListTicketsFromViewHeaders headers = {}, *ListTicketsFromViewQueries queries) returns TicketsResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/tickets`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Active Views
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/active(ListActiveViewsHeaders headers = {}, *ListActiveViewsQueries queries) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/active`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Views - Compact
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/compact(map<string|string[]> headers = {}) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/compact`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Count Views
    #
    # + headers - Headers to be sent with the request 
    # + return - Count of views 
    resource isolated function get api/v2/views/count(map<string|string[]> headers = {}) returns ViewsCountResponse|error {
        string resourcePath = string `/api/v2/views/count`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Count Tickets in Views
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/count_many(GetViewCountsHeaders headers = {}, *GetViewCountsQueries queries) returns ViewCountsResponse|error {
        string resourcePath = string `/api/v2/views/count_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Bulk Delete Views
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - No Content response 
    resource isolated function delete api/v2/views/destroy_many(BulkDeleteViewsHeaders headers = {}, *BulkDeleteViewsQueries queries) returns error? {
        string resourcePath = string `/api/v2/views/destroy_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Preview Views
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/views/preview(map<string|string[]> headers = {}) returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/preview`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Preview Ticket Count
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function post api/v2/views/preview/count(map<string|string[]> headers = {}) returns ViewCountResponse|error {
        string resourcePath = string `/api/v2/views/preview/count`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Search Views
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/search(SearchViewsHeaders headers = {}, *SearchViewsQueries queries) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # List Views By ID
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success response 
    resource isolated function get api/v2/views/show_many(ListViewsByIdHeaders headers = {}, *ListViewsByIdQueries queries) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/show_many`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Many Views
    #
    # + headers - Headers to be sent with the request 
    # + return - Success response 
    resource isolated function put api/v2/views/update_many(map<string|string[]> headers = {}) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/update_many`;
        http:Request request = new;
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List Workspaces
    #
    # + headers - Headers to be sent with the request 
    # + return - Success Response 
    resource isolated function get api/v2/workspaces(map<string|string[]> headers = {}) returns WorkspaceResponse|error {
        string resourcePath = string `/api/v2/workspaces`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Create Workspace
    #
    # + headers - Headers to be sent with the request 
    # + return - Created workspace 
    resource isolated function post api/v2/workspaces(V2WorkspacesBody payload, map<string|string[]> headers = {}) returns InlineResponse201|error {
        string resourcePath = string `/api/v2/workspaces`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Show Workspace
    #
    # + workspace_id - The id of the workspace
    # + headers - Headers to be sent with the request 
    # + return - Successful response 
    resource isolated function get api/v2/workspaces/[int workspace_id](ShowWorkspaceHeaders headers = {}) returns InlineResponse2008|error {
        string resourcePath = string `/api/v2/workspaces/${getEncodedUri(workspace_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Update Workspace
    #
    # + workspace_id - The id of the workspace
    # + headers - Headers to be sent with the request 
    # + return - OK 
    resource isolated function put api/v2/workspaces/[int workspace_id](WorkspacesworkspaceIdBody payload, UpdateWorkspaceHeaders headers = {}) returns InlineResponse2009|error {
        string resourcePath = string `/api/v2/workspaces/${getEncodedUri(workspace_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Delete Workspace
    #
    # + workspace_id - The id of the workspace
    # + headers - Headers to be sent with the request 
    # + return - No Content 
    resource isolated function delete api/v2/workspaces/[int workspace_id](DeleteWorkspaceHeaders headers = {}) returns error? {
        string resourcePath = string `/api/v2/workspaces/${getEncodedUri(workspace_id)}`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Bulk Delete Workspaces
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Succesful response 
    resource isolated function delete api/v2/workspaces/destroy_many(DestroyManyWorkspacesHeaders headers = {}, *DestroyManyWorkspacesQueries queries) returns string|error {
        string resourcePath = string `/api/v2/workspaces/destroy_many`;
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Reorder Workspaces
    #
    # + headers - Headers to be sent with the request 
    # + return - Succesful response 
    resource isolated function put api/v2/workspaces/reorder(WorkspacesReorderBody payload, map<string|string[]> headers = {}) returns string|error {
        string resourcePath = string `/api/v2/workspaces/reorder`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }
}
